//Creating the Account classmodel.Account = new DataClass("Accounts");//Add Contact attributes.model.Account.ID = new Attribute("storage", "long", "key auto");model.Account.name = new Attribute("storage", "string", "btree");model.Account.name.addEventListener("onSet", wordCaps2);model.Account.phone = new Attribute("storage", "string", "btree");model.Account.billingStreet = new Attribute("storage", "string", "btree");model.Account.billingCity = new Attribute("storage", "string", "btree");model.Account.billingState = new Attribute("storage", "string", "btree");model.Account.billingZip = new Attribute("storage", "string", "btree");model.Account.billingCountry = new Attribute("storage", "string", "btree");model.Account.shippingStreet = new Attribute("storage", "string", "btree");model.Account.shippingCity = new Attribute("storage", "string", "btree");model.Account.shippingState = new Attribute("storage", "string", "btree");model.Account.shippingZip = new Attribute("storage", "string", "btree");model.Account.shippingCountry = new Attribute("storage", "string", "btree");model.Account.website = new Attribute("storage", "string", "btree");model.Account.type = new Attribute("storage", "string", "btree");model.Account.industry = new Attribute("storage", "string", "btree");model.Account.annualRevenue = new Attribute("storage", "number", "btree");model.Account.owner = new Attribute("relatedEntity", "User", "User"); // relation to the User classmodel.Account.activityCollection = new Attribute("relatedEntities", "Activity", "account", {reversePath:true});model.Account.contactCollection = new Attribute("relatedEntities", "Contact", "account", {reversePath:true});model.Account.noteCollection = new Attribute("relatedEntities", "Note", "account", {reversePath:true});model.Account.collectionMethods = {};model.Account.collectionMethods.changeOwner = function(paramObj) {		if (!currentSession().belongsTo("Manager")) {return "You do not have permission to change the owner of a contact.";}		var currentAccountsCollection = this, //"this" contains our current company collection.		myUser = ds.User.find("ID = :1", paramObj.ownerID);			if (myUser !== null) {		var sessionRef = currentSession(); // Get session.		var promoteToken = sessionRef.promoteWith("Administrator"); //temporarily make this session Admin level.						var count = 0;		currentAccountsCollection.forEach(function(oneAccount) {			if (paramObj.accountsSelectionArr.indexOf(count) !== -1) {								var recentItem = ds.RecentItem.find("dataClassName == :1 && entityKey == :2", "accounts", oneAccount.ID);				if (recentItem) {					recentItem.remove();				}								oneAccount.owner = myUser;				oneAccount.save();							}			count++;		});				sessionRef.unPromote(promoteToken); //put the session back to normal. 	}		return "The owner has been changed.";};model.Account.collectionMethods.changeOwner.scope = "public";//Eventsmodel.Account.events = {};//onInit()model.Account.events.onInit = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		myUser = ds.User.find("ID = :1", myCurrentUser.ID);			if ((myCurrentUser !== null) && (myUser !== null)) {//if a user is logged in.				this.owner = myUser;	}		this.type = "-none-";	this.industry = "-none-";}; model.Account.events.onRestrictingQuery = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		sessionRef = currentSession(), // Get session.		result;			result = ds.Account.createEntityCollection(); //default to empty collection.		if (sessionRef.belongsTo("Administrator") || sessionRef.belongsTo("Manager")) {		result = ds.Account.all();	} else {		result = ds.Account.query("owner.ID = :1", myCurrentUser.ID);	}		return result;}